}
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
#> Instantiate DataFrame for reported data
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
i<-1
pages<-list()
pages[[i]]<-community_reminders
while (!is.null(another_page_cr)){
i<-i+1
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
#> Combine the pages using try to prevent the error stopping the process
if(is.null(data_cr[['results']])){
#
print("Null")
}
else{
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
}
}
?rbind_pages
?rbind.pages
??rbind.pages
is.null(another_page_cr)
is.null("null")
x<-NA
X
x
is.null(x)
is.na(x)
while (!is.na(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
}
while (!is.na(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
}
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
}
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
}
## facility reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_fr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=97992031-a62c-41fa-8654-86e6b689d813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_fr ,  add_headers("Authorization"= API_token))
data_fr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_fr))
#> Instantiate DataFrame for reported data
facility_reminders <- data_fr[['results']]
#> Get value of next(link to another page )
another_page_fr <- data_fr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
while (!is.null(another_page_fr)){
request <- GET(another_page_fr,  add_headers("Authorization"= API_token))
data_fr <- fromJSON(rawToChar(request$content))
another_page_fr <- data_fr[['next']]
reminders_fr <- data_fr[['results']]
#> Combine the pages using try to prevent the error stopping the process
facility_reminders <- rbind_pages(list(facility_reminders, reminders_fr))
}
data_cr[['results']]
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
class(community_reminders)
class(data_cr[["results"]])
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind(list(community_reminders, data_cr[['results']]))
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
#> Instantiate DataFrame for reported data
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
pages<-list()
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind(list(community_reminders, data_cr[['results']]))
}
#> Total number of rows just to be sure that its working
print(nrow(community_reminders))
print(nrow(community_reminders))
head(community_reminders)
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
#> Instantiate DataFrame for reported data
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind(community_reminders, data_cr[['results']])
}
names(reminders_cr)
names(community_reminders)
?rbind
head(reminders_cr)
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind(data.framecommunity_reminders), data.frame(reminders_cr))
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind(data.frame(community_reminders), data.frame(reminders_cr))
row.names(community_reminders)
row.names(reminders_cr)
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
#> Instantiate DataFrame for reported data
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
rownames(community_reminders)<-c()
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
rownames(reminders_cr)<-c()
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind(community_reminders, reminders_cr)
}
rownames(reminders_cr)
head(reminders_cr)
names(reminders_cr)
View(reminders_cr)
row.names(reminders_cr)
row.names(reminders_cr)<-c()
row.names(reminders_cr)
row.names(reminders_cr)<-NA
row.names(reminders_cr)<-c()
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(community_reminders, reminders_cr)
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, reminders_cr))
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
#> Instantiate DataFrame for reported data
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
rownames(community_reminders)<-c()
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
row.names(reminders_cr)<-c()
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, reminders_cr))
}
?rbind_pages
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
#> Instantiate DataFrame for reported data
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
rownames(community_reminders)<-c()
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
reminders_cr <- data_cr[['results']]
row.names(reminders_cr)<-c()
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages( reminders_cr)
}
reminders_cr <- data_cr[['results']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages( reminders_cr)
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
#> Instantiate DataFrame for reported data
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
rownames(community_reminders)<-c()
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
}
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
rownames(community_reminders)<-c()
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
another_page_cr <- data_cr[['next']]
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
}
n data_cr[['next']]
data_cr[['next']]
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
}
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages( data_cr[['results']])
}
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content), flatten = T)
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(community_reminders, data_cr[['results']]))
}
data_cr$resultsz
data_cr$results
class(data_cr$results)
community_reminders$values
head(community_reminders$values)
head(community_reminders$values,2)
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
pages<-list()
for (i in 0:5){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
pages[[i+1]]<-data_cr$results
#> Combine the pages using try to prevent the error stopping the process
#community_reminders <- rbind_pages(list(community_reminders, data_cr$results))
}
community_reminders<-rbind_pages(list(pages, community_reminders))
pages[[1]]
pages[[2]]
pages[[3]]
pages[[4]]
pages[[5]]
community_reminders<-rbind_pages(pages)
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> Combine the pages using try to prevent the error stopping the process
community_reminders <- rbind_pages(list(data_cr$results))
}
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
#> Instantiate DataFrame for reported data
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> Combine the pages using try to prevent the error stopping the process
community_reminders1 <- rbind_pages(list(data_cr$results))
}
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
## community daily reminders
#> API Token
API_token <- "Token ea53c1a6853e6f64b4998b3d653740f4c43aeeae"
#> First URL without pagination
url_api_cr <- "https://rapidpro.ona.io/api/v2/runs.json?flow=b016a5fc-1fff-4fd0-82fc-04f6a83c2813"
#> Request for data. This need to be converted to a function
request <- GET(url_api_cr ,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> List objects names >> "next", "previous", "results"
#>  next == link to next page. Null if there are no other pages
#>  previous == link to next page. By default its NULL
#>  results == results fro this link. By default its 250 record. Check inside values for the actual data.
print(names(data_cr))
#> Instantiate DataFrame for reported data
community_reminders <- data_cr[['results']]
#> Get value of next(link to another page )
another_page_cr <- data_cr[['next']]
#> Check if next is null/blank. Basically the API is paginating 250 records
#> if next is null it means on one page is available (Records less than 250)
#> create a loop to check if next is null, if not querry the next url and ammend the data frame
while (!is.null(another_page_cr)){
request <- GET(another_page_cr,  add_headers("Authorization"= API_token))
data_cr <- fromJSON(rawToChar(request$content))
#> Combine the pages using try to prevent the error stopping the process
community_reminders1 <- rbind_pages(list(data_cr$results))
}
#library(squire)
#install.packages("devtools")
#devtools::install_github("RamiKrispin/coronavirus", force = TRUE)
#install.packages("coronavirus")
library(coronavirus)
data(coronavirus)
update_dataset()
setwd("~/Dropbox/Dropbox/GitHub/vaccination.github.io")
library(flexdashboard)
library(tidyverse)
library(sf)
library(RecordLinkage)
install.packages("RecordLinkage")
library(RecordLinkage)
